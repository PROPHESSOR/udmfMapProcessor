/**
 * Copyright (c) 2018 PROPHESSOR
 * 
 * This software is released under the MIT License.
 * https://opensource.org/licenses/MIT
 */

const fs = require('fs');

const IN_FILE = 'test/test.udmf';
const OUT_FILE = 'test/test.json';

module.exports = {
    udmf2json(infile, outfile) {
        const file = '[\n' +
            fs.readFileSync(infile, 'utf8')
                .replace(/(\/\/|namespace).+?\n/g, '')                                      // Remove comments
                .replace(/=/g, ': ')                                                        // = -> :
                .replace(/;/g, ',')                                                         // ; -> ,
                .replace(/(linedef|sidedef|vertex|sector|thing)\s*\n*{/g, '["$1", {')       // XXX{ -> ["XXX", {]
                .replace(/}/g, '}], ')                                                      // } -> }], 
                .replace(/\n(.+?):/g, '"$1":')                                              // v1: -> "v1":
                .replace(/,(\s*\n*\s*})/g, '$1')                                            // Remove last "," (attributes)
                .replace(/,\s*$/, '')                                                       // Remove last "," (file)
            + '\n]';

        fs.writeFileSync(outfile, file);

        return JSON.parse(file);
    },
    json2udmf(infile, outfile) {
        const file = typeof infile === 'string' ? require(infile) : infile;

        let out = '// Generated by PROPHESSOR\'s udmf2json converter\n\nnamespace = "zdoom";\n\n';

        for (const block of file) {
            out += `${block[0]}`;
            if(typeof block[2] === 'number') out += ` // #${block[2]}`;
            out += '\n{\n';

            for (const key in block[1]) {
                let value = block[1][key];
                if (typeof value === 'string') value = `"${value}"`;
                if (key === 'x' || key === 'y') value = value.toFixed(3);

                out += `    ${key} = ${value};\n`;
            }

            out += '}\n\n';
        }

        if (outfile) fs.writeFileSync(outfile, out);

        return out;
    },
    jsonDecompress(json) {
        const out = {
            thing: [],
            linedef: [],
            sidedef: [],
            vertex: [],
            sector: []
        }

        for (const block of json) {
            try {
                out[block[0]].push(block[1]);
            } catch(e) {
                console.error(`Неизвестный блок ${block[0]}`, e);
            }
        }

        return out;
    },
    jsonCompress(json) {
        const things = json.thing.map((e, i) => ['thing', e, i]);
        const linedefs = json.linedef.map((e, i) => ['linedef', e, i]);
        const sidedefs = json.sidedef.map((e, i) => ['sidedef', e, i]);
        const vertexes = json.vertex.map((e, i) => ['vertex', e, i]);
        const sectors = json.sector.map((e, i) => ['sector', e, i]);

        return [
            ...things,
            ...linedefs,
            ...sidedefs,
            ...vertexes,
            ...sectors
        ]
    }
}

if (!module.parent) return module.exports(IN_FILE, OUT_FILE);